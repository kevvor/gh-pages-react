{"version":3,"sources":["assets/text-tone.mp3","TextBubble/TextBubble.js","App/App.js","serviceWorker.js","index.js"],"names":["module","exports","__webpack_require__","p","TextBubble","props","isHrefBubble","data","p1","p2","aHref","aText","message","includes","chunks","split","react_default","a","createElement","className","href","App","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","loadTextBubbles","bubbleTexts","forEach","msg","i","setTimeout","allTexts","state","_allTexts","concat","DOMtextTone","play","setState","currentText","window","scrollTo","document","body","scrollHeight","error","console","log","textVisible","_this2","bubbles","map","text","index","src_TextBubble_TextBubble","key","id","ref","textTone","src","type","Component","Boolean","location","hostname","match","ReactDOM","render","src_App_App","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"+EAAAA,EAAAC,QAAiBC,EAAAC,EAAuB,0PCqCzBC,SAlCI,SAACC,GAChB,IAAIC,GAAe,EAEbC,EAAO,CACTC,GAAI,GACJC,GAAI,GACJC,MAAO,GACPC,MAAO,IAGX,GAAIN,EAAMO,QAAQC,SAAS,MAAO,CAC9B,IAAMC,EAAST,EAAMO,QAAQG,MAAM,gBAEnCR,EAAKC,GAAQM,EAAO,GACpBP,EAAKI,MAAQG,EAAO,GAAGC,MAAM,KAAK,GAClCR,EAAKG,MAAQI,EAAO,GAAGC,MAAM,KAAK,GAClCR,EAAKE,GAAQK,EAAO,GAEpBR,GAAe,EAlBO,IAqBlBE,EAAyBD,EAAzBC,GAAIC,EAAqBF,EAArBE,GAAIC,EAAiBH,EAAjBG,MAAOC,EAAUJ,EAAVI,MAEvB,OACIK,EAAAC,EAAAC,cAAA,OAAKC,UAAU,UACXH,EAAAC,EAAAC,cAAA,OAAKC,UAAU,QACVb,EACGU,EAAAC,EAAAC,cAAA,SAAIV,EAAGQ,EAAAC,EAAAC,cAAA,KAAGE,KAAMV,GAAQC,GAAWF,GACnCO,EAAAC,EAAAC,cAAA,SAAIb,EAAMO,6BCkDfS,qBA3EX,SAAAA,EAAYhB,GAAO,IAAAiB,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAJ,IACfC,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAF,GAAAO,KAAAH,KAAMpB,KAkBVwB,gBAAkB,WACd,IAGMC,EAAc,CAChB,8DACA,kDACA,4IACA,mFACA,kGAGJA,EAAYC,QAAQ,SAACC,EAAKC,GACtB,IAEIC,WAAW,WAAM,IACLC,EAAab,EAAKc,MAAlBD,SACFE,EAAY,GAAGC,OAAOH,EAAUL,EAAYG,IAElDX,EAAKiB,YAAYC,OAEjBlB,EAAKmB,SAAS,CAAEN,SAAUE,EAAWK,YAAaV,IAClDW,OAAOC,SAAS,EAAGC,SAASC,KAAKC,eARb,KAATd,EAAI,GAAY,GAUjC,MAAOe,GACLC,QAAQC,IAAIF,OAzCpB1B,EAAKc,MAAQ,CACTD,SAAU,GACVO,YAAa,GACbS,aAAa,GANF7B,mFAWVG,KAAKW,MAAMe,aAEZ1B,KAAKgB,SAAS,CAAEU,aAAa,IAGjC1B,KAAKI,mDAiCA,IAAAuB,EAAA3B,KAEC4B,EAAU5B,KAAKW,MAAMD,SAASmB,IAAI,SAACC,EAAMC,GAC3C,OACIxC,EAAAC,EAAAC,cAACuC,EAAD,CAAYtC,UAAS,QAAAmB,OAAUkB,GAAS5C,QAAS2C,EAAMG,IAAKF,MAIpE,OACIxC,EAAAC,EAAAC,cAAA,OAAKC,UAAU,OACXH,EAAAC,EAAAC,cAAA,OAAKyC,GAAG,YACPlC,KAAKW,MAAMe,YACRnC,EAAAC,EAAAC,cAAA,WACIF,EAAAC,EAAAC,cAAA,OAAKC,UAAU,yBACTkC,IAGZ,KACFrC,EAAAC,EAAAC,cAAA,SAAO0C,IAAM,SAACC,GAAeT,EAAKb,YAAcsB,IAC5C7C,EAAAC,EAAAC,cAAA,UAAQ4C,IAAKD,IAAUE,KAAK,wBArE9BC,cCKEC,QACW,cAA7BtB,OAAOuB,SAASC,UAEe,UAA7BxB,OAAOuB,SAASC,UAEhBxB,OAAOuB,SAASC,SAASC,MACvB,2DCVNC,IAASC,OAAOtD,EAAAC,EAAAC,cAACqD,EAAD,MAAS1B,SAAS2B,eAAe,SDmH3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.3c547637.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/text-tone.0bb189ca.mp3\";","import React from 'react';\nimport './TextBubble.css';\n\nconst TextBubble = (props) => {\n    let isHrefBubble = false;\n\n    const data = {\n        p1: '',\n        p2: '',\n        aHref: '',\n        aText: ''\n    }\n\n    if (props.message.includes(\"{{\")) {\n        const chunks = props.message.split(/\\{\\{(.*)\\}\\}/);\n\n        data.p1    = chunks[0];\n        data.aText = chunks[1].split('|')[0];\n        data.aHref = chunks[1].split('|')[1];\n        data.p2    = chunks[2];\n\n        isHrefBubble = true;\n    }\n\n    const { p1, p2, aHref, aText } = data;\n\n    return (\n        <div className=\"bubble\">\n            <div className=\"text\">\n                {isHrefBubble ?\n                    <p>{p1}<a href={aHref}>{aText}</a>{p2}</p> :\n                    <p>{props.message}</p>}\n            </div>\n        </div>\n    );\n}\n\nexport default TextBubble;\n","import React, { Component } from 'react';\nimport TextBubble from '../TextBubble/TextBubble';\nimport textTone from '../assets/text-tone.mp3';\nimport './App.css';\n\nclass App extends Component {\n    constructor(props) {\n        super(props)\n\n        this.state = {\n            allTexts: [],\n            currentText: '',\n            textVisible: false\n        }\n    }\n\n    componentDidMount() {\n        if (!this.state.textVisible) {\n            // Figure out a better way to do this than simply hiding everything before it scrolls down to the bottom\n            this.setState({ textVisible: true });\n        }\n\n        this.loadTextBubbles();\n    }\n\n    loadTextBubbles = () => {\n        const prevWorkLink = '<a href=\"#\">previous work</a>';\n        const contactMeLink = '<a href=\"#\">contact me</a>';\n\n        const bubbleTexts = [\n            \"Hey there! My name is Keano, nice to meet you. \\u{1F44B}\",\n            \"I'm a web developer based in Vancouver, Canada.\",\n            \"I mostly work with front end Javasript frameworks and Node.js, but I love new challenges so don't hesitate to reach about other projects!\",\n            \"You can find some of my {{projects|https://kevvor.github.io/#my-projects}} here.\",\n            \"Or send me an {{email|mailto:keano@voelkl.co?subject=Hey Keano}} to chat with me. \\u{1F642}\"\n        ]\n\n        bubbleTexts.forEach((msg, i) => {\n            try {\n                const timer = (i + 1) * 1000 * 2;\n                setTimeout(() => {\n                    const { allTexts } = this.state;\n                    const _allTexts = [].concat(allTexts, bubbleTexts[i]);\n\n                    this.DOMtextTone.play();\n\n                    this.setState({ allTexts: _allTexts, currentText: msg });\n                    window.scrollTo(0, document.body.scrollHeight);\n                }, timer);\n            } catch (error) {\n                console.log(error);\n            }\n        });\n    }\n\n    render() {\n        // TODO React router this thing\n        const bubbles = this.state.allTexts.map((text, index) => {\n            return (\n                <TextBubble className={`text-${index}`} message={text} key={index} />\n            )\n        });\n\n        return (\n            <div className=\"app\">\n                <div id=\"divider\"></div>\n                {this.state.textVisible ?\n                    <div>\n                        <div className=\"text-bubble-container\">\n                            { bubbles }\n                        </div>\n                    </div>\n                : null }\n                <audio ref={ (textTone) => { this.DOMtextTone = textTone } }>\n                    <source src={textTone} type=\"audio/mpeg\" ></source>\n                </audio>\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://goo.gl/SC7cgQ'\n          );\n        });\n      } else {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              console.log('New content is available; please refresh.');\n\n              // Execute callback\n              if (config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}